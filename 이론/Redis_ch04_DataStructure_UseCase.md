# sorted set

## 실시간 리더보드

- 유저이름과 스코어를 sorted set에 저장하여 자연스럽게 순위대로 정렬된다.

- 요구사항
    - 사용자 스코어 기반 정렬
    - 사용자의 증가에 따라 가공해야 할 데이터가 계속 증가
    - 실시간으로 반영돼야함
    - 특정 그룹별 순위 등 여러 수학적 계산이 빠르게 수행돼야 함

- 활용 예시1) 사용자별 랭킹
    - `ZADD`로 데이터 저장
    - `ZRANGE`로 스코어 오름차순 조회
    - `ZREVRANGE`로 스코어 내림차순 조회
    - `ZADD`로 사용자의 스코어 수정

- 활용 예시2) 랭킹 합산 → 일자별 랭킹 등에 활용
    - `ZUNIONSTORE`로 키에 연결된 각 아이템의 스코어 합산

- 활용 예시3) 가중치 기반 랭킹
    - `WEIGHTS`를 통해 가중치를 곱하여 랭킹을 구함

## 최근 검색 기록

- 최근 N개의 중복없는 검색 기록을 유저별로 확인하기 위해 sorted set 활용

- 요구사항
    - 유저별 다른 키워드 노출
    - 검색 내역은 중복 제거
    - 가장 최근 검색한 N개의 키워드만 사용자에게 노출

- 활용 예시
    - 날짜를 숫자로 이어붙여 스코어로 지정 ex) 20240505
    - `ZREMRANGEBYRANK`로 0 ~ N 번쨰 데이터를 조회

# set

## 태그 기능

- 블로그의 포스트에 중복없이 태그를 저장

- 요구사항
    - 태그는 중복되지 않음
    - 순서는 중요하지 않음
    - 태그를 포함한 포스트를 조회할 수 있어야 함

- 활용 예시
    - `SADD`로 데이터 추가
    - `SMEMBERS`를 통해 특정 태그를 갖는 포스트를 조회
    - `SINTER`를 통해 특정 태그들을 모두 포함하는 포스트 조회

# 랜덤키 command

## 랜덤 데이터 추출

- 저장된 key 중 랜덤하게 하나를 가져오거나 value를 랜덤하게 가져올때 사용

- 요구사항
    - 랜덤 게임 매칭
    - 이벤트 응모한 유저 추첨

- 활용 예시
    - `RANDOMKEY`로 저장된 전체 키 중 하나를 랜덤하게 조회
    - `HRANDFIELD`, `SRANDMEMBER`, `ZRANDOMMEMBER`는 각각 hash, set, sorted set에 저장된 아이템 중 랜덤한 하나의 value 조회

# 카운팅 방법

## 좋아요 처리하기

- set을 통해 다양한 좋아요 기능에 필요한 조회 수행

- 요구사항
    - 하나의 유저는 같은 글에 한 번만 좋아요 누를 수 있음
    - 트래픽이 어느정도 많아서 관계형 데이터베이스로는 어려울 때
    - 글 혹은 댓글별 좋아요 개수 조회
    - 어떤 유저가 어떤 글에 좋아요를 눌렀는지 조회

- 활용 예시
    - set에 `SADD`로 유저의 id를 저장
    - `SCARD`로 글 혹은 댓글별 좋아요 개수 조회

## 읽지 않은 메시지 수 카운팅하기

- hash 자료구조로 읽지 않은 채팅 메시지 개수 파악

- 요구사항
    - 사용자가 속한 채팅방별로 읽지 않은 메시지 수 조회
    - 중복 고려 없이 단순히 개수만 파악하면 됨

- 활용 예시
    - hash에 유저의 채팅방별 읽지 않은 메시지 수를 저장
    - `HINCRBY`로 새로운 메시지 수신시 숫자 증가, 메시지 삭제시 음수를 `HINCRBY`에 사용하여 숫자 감소

## DAU 구하기

- bit 자료구조로 서비스 접속한 사용자수 구하기

- 요구사항
    - 1천만명이 넘는 서비스에도 사용 가능해야함
    - 메모리를 효율적으로 사용해야함
    - 이벤트 등의 이유로 매일 방문한 사용자 조회 가능해야함

- 활용 예시
    - 1천만명의 사용자는 1천만개의 비트로 나타낼 수 있으며 1.2MB 만 사용하여 계산 가능
    - 접속한 유저가 있다면 유저 id의 비트를 1로 설정 (유저 id는 숫자인 경우)
    - `BITCOUNT`로 전체 1의 개수 (서비스 접속 사용자수) 조회
    - `BITOP`과 `AND`연산으로 며칠간 연속 출석한 유저 id 조회

## hyperloglog를 이용한 애플리케이션 미터링

- 사용자가 서비스를 얼마나 이용했는지 측정

- 요구사항
    - 대용량 데이터 처리 필요
    - 서비스의 규모에 따라 초당 수천 건 이상의 작업 발생 가능
    - 높은 처리량과 낮은 대기 시간을 가져야 함
    - API 호출마다 사용자별 카운팅 필요
    - 1% 미만의 오차는 허용 가능, 정확한 데이터를 다시 조회하지 않아도 됨 (개수만 조회하면 됨)

- 활용 예시
    - `PFADD`를 통해 유저 id와 API 호출시 발생한 로그의 id를 저장
    - `PFCOUNT`를 통해 유저의 API 호출 횟수 조회

# geospatial

## 위치 기반 애플리케이션 개발

- 위치 기반 데이터를 저장하고 거리 계산 및 조회하는 서비스

- 요구사항
    - 사용자의 현재 위치 파악
    - 이동에 따른 실시간 변동 위치 업데이트
    - 사용자 위치 기준으로 근처 장소 검색

- 활용 예시
    - `GEOADD`로 유저의 위치 좌표 저장
    - `GEOPOS`로 위치 좌표 조회
    - `GEOSEARCH`로 반경 ?km 내에 저장된 장소 검색